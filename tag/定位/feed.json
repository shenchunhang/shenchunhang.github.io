{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"定位\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/04/21/max-http-header-size%E5%BC%95%E8%B5%B7%E7%9A%84OOM/",
            "url": "http://example.com/2024/04/21/max-http-header-size%E5%BC%95%E8%B5%B7%E7%9A%84OOM/",
            "title": "max-http-header-size引起的OOM",
            "date_published": "2024-04-21T15:13:22.000Z",
            "content_html": "",
            "tags": [
                "java",
                "定位"
            ]
        },
        {
            "id": "http://example.com/2024/04/18/websocketClient%E8%AE%B0%E5%BE%97close/",
            "url": "http://example.com/2024/04/18/websocketClient%E8%AE%B0%E5%BE%97close/",
            "title": "websocketClient记得close",
            "date_published": "2024-04-18T14:30:58.000Z",
            "content_html": "<h2 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>最近开发了一个特性，关于 websocket 的功能，代码量直接给感到了 5k, 联调都好了，程序就挂在服务器上，然后就没管了，今天发现这个服务器，卡卡的，一看 CPU 占用 500%, 惊了</p>\n<h2 id=\"定位\"><a class=\"markdownIt-Anchor\" href=\"#定位\">#</a> 定位</h2>\n<h3 id=\"先看哪个线程这么吃cpu\"><a class=\"markdownIt-Anchor\" href=\"#先看哪个线程这么吃cpu\">#</a> 先看哪个线程这么吃 CPU</h3>\n<p>top -Hp pid, 这个是查看线程，直接 top 显示的都是进程<br>\n然后取 CPU 占用最高的一个，printf “% x\\n” 线程号，<br>\n 再用 jstack pid &gt; stack.txt<br>\n 在 stack.txt 里面检索一下，发现是 GC 的线程，看了 CPU 占用最高的几个线程，都是 GC 的，然后突然发现端倪，为什么 Thread-XXX 的线程这么多呢，有几千个，看栈帧，看线程名，只能知道是系统龙出来的，但是我自己弄的线程都是有给命名的，感觉很奇怪</p>\n<h3 id=\"先看gc情况-判断是一直在gc\"><a class=\"markdownIt-Anchor\" href=\"#先看gc情况-判断是一直在gc\">#</a> 先看 GC 情况，判断是一直在 GC</h3>\n<p>用 jstat -gcutil pid 1000 10, 发现 FGC 很少，但是 YGC 却来得很多，还一直再增长，这种情况，没有 FGC, 一直 YGC, 那多半，并没有大对象，如果是大对象就直接进老年代，触发 FGC 了</p>\n<h3 id=\"查看heapdump\"><a class=\"markdownIt-Anchor\" href=\"#查看heapdump\">#</a> 查看 heapdump</h3>\n<p>本来准备先 jmap -heap pid 的，结果上传到服务器的 jdk 和 jre 版本不支持，索性直接 jmap -dump:format=b,file=home/xxx/pid.dump, 推荐用 mat（Memory Analyzer Tool）, visualvm, 还是太简陋了，不容易分析，大概看了一遍，没有自己封装的对象在，<br>\n 然后我又检索了一下 websocket 的类名，发现 2000 多个，哦和，问题肯定出现在 new WebscoketClient 的地方，走读了一下代码，发现连接不通的时候没有 close, 导致 GC 一直不把他当成垃圾</p>\n<h3 id=\"源码解析\"><a class=\"markdownIt-Anchor\" href=\"#源码解析\">#</a> 源码解析</h3>\n<p>WebSocketClient 中有两个线程对象，<br>\nprivate Thread writeThread;<br>\nprivate Thread connectReadThread;<br>\n 所以现象中有线程数爆炸，且命名也是系统给的，让人混淆<br>\n再说为什么会有这么多自定义的 WebSocketClient 对象，因为代码终有重连机制<br>\n改正也简单，加上 连接失败，机上 close 就可以了</p>\n<pre><code>\npublic abstract class WebSocketClient extends AbstractWebSocket implements Runnable, WebSocket {\n\n&#x2F;**\n* The URI this channel is supposed to connect to.\n*&#x2F;\nprotected URI uri &#x3D; null;\n\n&#x2F;**\n* The underlying engine\n*&#x2F;\nprivate WebSocketImpl engine &#x3D; null;\n\n&#x2F;**\n* The socket for this WebSocketClient\n*&#x2F;\nprivate Socket socket &#x3D; null;\n\n&#x2F;**\n* The SocketFactory for this WebSocketClient\n*\n* @since 1.4.0\n*&#x2F;\nprivate SocketFactory socketFactory &#x3D; null;\n\n&#x2F;**\n* The used OutputStream\n*&#x2F;\nprivate OutputStream ostream;\n\n&#x2F;**\n* The used proxy, if any\n*&#x2F;\nprivate Proxy proxy &#x3D; Proxy.NO_PROXY;\n\n&#x2F;**\n* The thread to write outgoing message\n*&#x2F;\nprivate Thread writeThread;\n\n&#x2F;**\n* The thread to connect and read message\n*&#x2F;\nprivate Thread connectReadThread;\n\n&#x2F;**\n* The draft to use\n*&#x2F;\nprivate Draft draft;\n\n&#x2F;**\n* The additional headers to use\n*&#x2F;\nprivate Map&lt;String, String&gt; headers;\n\n&#x2F;**\n* The latch for connectBlocking()\n*&#x2F;\nprivate CountDownLatch connectLatch &#x3D; new CountDownLatch(1);\n\n&#x2F;**\n* The latch for closeBlocking()\n*&#x2F;\nprivate CountDownLatch closeLatch &#x3D; new CountDownLatch(1);\n\n&#x2F;**\n* The socket timeout value to be used in milliseconds.\n*&#x2F;\nprivate int connectTimeout &#x3D; 0;\n\n&#x2F;**\n* DNS resolver that translates a URI to an InetAddress\n*\n* @see InetAddress\n* @since 1.4.1\n*&#x2F;\nprivate DnsResolver dnsResolver &#x3D; null;</code></pre>",
            "tags": [
                "java",
                "定位",
                "JVM"
            ]
        },
        {
            "id": "http://example.com/2024/03/22/struts2%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0-%E5%8F%AA%E8%83%BD%E6%8E%A5%E6%94%B6256%E4%B8%AA/",
            "url": "http://example.com/2024/03/22/struts2%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0-%E5%8F%AA%E8%83%BD%E6%8E%A5%E6%94%B6256%E4%B8%AA/",
            "title": "struts2集合参数-只能接收256个",
            "date_published": "2024-03-22T13:47:32.000Z",
            "content_html": "<h2 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>测试那边转过来一个问题单，开发这边初步定位是 struts 框架接收集合参数只能接收到 256 个</p>\n<h2 id=\"定位\"><a class=\"markdownIt-Anchor\" href=\"#定位\">#</a> 定位</h2>\n<h3 id=\"google一下\"><a class=\"markdownIt-Anchor\" href=\"#google一下\">#</a> google 一下</h3>\n<p>先直接 google 了一下，感觉回答有点偏，说是 struts2.5.15 升级到 2.5.30 就会有这个问题，是 struts 改用 ArrayList 的 TypeConverter, 我自己去代码里面看根本咩有限制</p>\n<pre><code>\npublic Object convertValue(Map&lt;String, Object&gt; context, Object target, Member member, String propertyName, Object value, Class toType) {\nCollection result;\nClass memberType &#x3D; String.class;\n    if (target !&#x3D; null) {\n        memberType &#x3D; objectTypeDeterminer.getElementClass(target.getClass(), propertyName, null);\n        if (memberType &#x3D;&#x3D; null) {\n            memberType &#x3D; String.class;\n        }\n    }\n    if (toType.isAssignableFrom(value.getClass())) {\n        &#x2F;&#x2F; no need to do anything\n        result &#x3D; (Collection) value;\n    } else if (value.getClass().isArray()) {\n        Object[] objArray &#x3D; (Object[]) value;\n        TypeConverter converter &#x3D; getTypeConverter(context);\n        result &#x3D; createCollection(toType, memberType, objArray.length);\n        for (Object anObjArray : objArray) {\n            Object convertedValue &#x3D; converter.convertValue(context, target, member, propertyName, anObjArray, memberType);\n            if (!TypeConverter.NO_CONVERSION_POSSIBLE.equals(convertedValue)) {\n                result.add(convertedValue);\n            }\n        }\n    } else if (Collection.class.isAssignableFrom(value.getClass())) {\n        Collection col &#x3D; (Collection) value;\n        TypeConverter converter &#x3D; getTypeConverter(context);\n        result &#x3D; createCollection(toType, memberType, col.size());\n        for (Object aCol : col) {\n            Object convertedValue &#x3D; converter.convertValue(context, target, member, propertyName, aCol, memberType);\n            if (!TypeConverter.NO_CONVERSION_POSSIBLE.equals(convertedValue)) {\n                result.add(convertedValue);\n            }\n        }\n    } else {\n        result &#x3D; createCollection(toType, memberType, -1);\n        TypeConverter converter &#x3D; getTypeConverter(context);\n        Object convertedValue &#x3D; converter.convertValue(context, target, member, propertyName, value, memberType);\n        if (!TypeConverter.NO_CONVERSION_POSSIBLE.equals(convertedValue)) {\n            result.add(convertedValue);\n        }\n    }\n    return result;\n}</code></pre>\n<h4 id=\"strutsognlexpressionmaxlength\"><a class=\"markdownIt-Anchor\" href=\"#strutsognlexpressionmaxlength\">#</a> struts.ognl.expressionMaxLength</h4>\n<p>这时候就这专门去 clone 了一下 struts 的仓库<br>\n先切换到 2.5.33 版本，然后曲剧检索了一下 256, 还真让找到了一处配置</p>\n<img loading=\"lazy\" data-src=\"/2024/03/22/struts2%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0-%E5%8F%AA%E8%83%BD%E6%8E%A5%E6%94%B6256%E4%B8%AA/Snipaste_2024-04-22_22-01-35.png\" class=\"\" title=\"struts.ognl.expressionMaxLength\">\n<p>但是被注释掉了，翻译过来，不配置的话，就不会被限制，实际情况，本来就没有设置这个参数，应该和在这个配置没有关系，而且实际给的参数列表超过了 256, 这个参数是接收 OGNL 的个数，我们出现的问题是 OGNL 集合参数被限制在 256 以内，</p>\n<h4 id=\"strutsognlautogrowthcollectionlimit\"><a class=\"markdownIt-Anchor\" href=\"#strutsognlautogrowthcollectionlimit\">#</a> struts.ognl.autoGrowthCollectionLimit</h4>\n<p>无奈，只得继续看提交记录，好在提交记录 并不是很多，看着看着，又发现了一处</p>\n<pre><code>\npublic Object getProperty(Map context, Object target, Object name) throws OgnlException {\n    if (ReflectionContextState.isGettingByKeyProperty(context)\n            || name.equals(XWorkCollectionPropertyAccessor.KEY_PROPERTY_FOR_CREATION)) {\n        return _sAcc.getProperty(context, target, name);\n    } else if (name instanceof String) {\n        return super.getProperty(context, target, name);\n    }\n    ReflectionContextState.updateCurrentPropertyPath(context, name);\n    Class lastClass &#x3D; (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n    String lastProperty &#x3D; (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n    \n    if (name instanceof Number\n            &amp;&amp; ReflectionContextState.isCreatingNullObjects(context)\n            &amp;&amp; objectTypeDeterminer.shouldCreateIfNew(lastClass,lastProperty,target,null,true)) {\n\n        List list &#x3D; (List) target;\n        int index &#x3D; ((Number) name).intValue();\n        int listSize &#x3D; list.size();\n\n        if (lastClass &#x3D;&#x3D; null || lastProperty &#x3D;&#x3D; null) {\n            return super.getProperty(context, target, name);\n        }\n        Class beanClass &#x3D; objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n        if (listSize &lt;&#x3D; index) {\n            Object result;\n            if (index &gt; autoGrowCollectionLimit) {\n                throw new OgnlException(&quot;Error auto growing collection size to &quot; + index + &quot; which limited to &quot;\n                                        + autoGrowCollectionLimit);\n            }\n            for (int i &#x3D; listSize; i &lt; index; i++) {\n                list.add(null);\n            }\n            try {\n                list.add(index, result &#x3D; objectFactory.buildBean(beanClass, context));\n            } catch (Exception exc) {\n                throw new XWorkException(exc);\n            }\n            return result;\n        } else if (list.get(index) &#x3D;&#x3D; null) {\n            Object result;\n            try {\n                list.set(index, result &#x3D; objectFactory.buildBean(beanClass, context));\n            } catch (Exception exc) {\n                throw new XWorkException(exc);\n            }\n            return result;\n        }\n    }\n    return super.getProperty(context, target, name);\n}</code></pre>\n<img loading=\"lazy\" data-src=\"/2024/03/22/struts2%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0-%E5%8F%AA%E8%83%BD%E6%8E%A5%E6%94%B6256%E4%B8%AA/Snipaste_2024-04-22_22-28-18.png\" class=\"\" title=\"struts.ognl.autoGrowthCollectionLimit\">\n<p>早知道就一起检索 255 了，还看了这么多提交记录，这次直接到 struts 的配置里面加上，测试了一下，果然可以</p>\n<h4 id=\"吐槽\"><a class=\"markdownIt-Anchor\" href=\"#吐槽\">#</a> 吐槽</h4>\n<p>struts 真的可以，增加了 default 配置，也不写到版本更新里面去，还得自己来看源码才能知道</p>\n<h4 id=\"推想\"><a class=\"markdownIt-Anchor\" href=\"#推想\">#</a> 推想</h4>\n<p>struts.ognl.expressionMaxLength 这个配置，看了一下他们的 issue, 还是感觉挺好笑的，2.5.21 加上后，2.5.22 又给注释掉，实际外发的版本 2.5.21 都没了，<br>\n<a href=\"https://github.com/apache/struts/pull/380\">struts.ognl.expressionMaxLength 讨论</a></p>\n<img loading=\"lazy\" data-src=\"/2024/03/22/struts2%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0-%E5%8F%AA%E8%83%BD%E6%8E%A5%E6%94%B6256%E4%B8%AA/Snipaste_2024-04-22_22-44-21.png\" class=\"\" title=\"2.5.21缺失\">",
            "tags": [
                "java",
                "定位",
                "struts2"
            ]
        },
        {
            "id": "http://example.com/2023/09/15/oom-help/",
            "url": "http://example.com/2023/09/15/oom-help/",
            "title": "快速定位OOM问题",
            "date_published": "2023-09-15T13:38:44.000Z",
            "content_html": "<h2 id=\"oom的原因\"><a class=\"markdownIt-Anchor\" href=\"#oom的原因\">#</a> OOM 的原因</h2>\n<h3 id=\"申请了大量的对象\"><a class=\"markdownIt-Anchor\" href=\"#申请了大量的对象\">#</a> 申请了大量的对象</h3>\n<p>写查询语句，不加 limit, 直接查到全表了</p>\n<pre><code>&lt;select&gt;\n    select id, name, .... from user\n    &lt;where&gt;\n        &lt;if test&#x3D;&#39;name !&#x3D;null &amp;&amp; name!&#x3D;&#39;&#39;&#39;&gt;\n            name &#x3D; #{name}\n        &lt;&#x2F;if&gt;\n    &lt;&#x2F;where&gt;\n&lt;&#x2F;select&gt;</code></pre>\n<p>当 name 等于 null 或者空字符串时，直接变成了查全表，有条军规就是查询必加 limit</p>\n<h3 id=\"内存用尽-资源不释放\"><a class=\"markdownIt-Anchor\" href=\"#内存用尽-资源不释放\">#</a> 内存用尽，资源不释放</h3>\n<p>Map 一直存，不做容量控制。定时任务最常见，要么是忘了 clear (), 要么就是没有设置 lru 之类的淘汰算法.<br>\n 还有就是 IO 对象不释放，记得调用 close () 呀<br>\n文件的话，记得调用 close (), 或者用 try-resource 语法糖<br>\n如果是连接对象的话，可以用连接池，保证下限</p>\n<h3 id=\"服务器内存真的低\"><a class=\"markdownIt-Anchor\" href=\"#服务器内存真的低\">#</a> 服务器内存真的低</h3>\n<p>我们的开发环境，单台只给了 16G, 感觉数据多一点，就卡的不行<br>\n可以用命令看下当前 堆的状态</p>\n<pre><code>\njmap -heap</code></pre>\n<h2 id=\"定位方法\"><a class=\"markdownIt-Anchor\" href=\"#定位方法\">#</a> 定位方法</h2>\n<h3 id=\"先看一眼-当前已经有的日志文件-业务日志和gc日志\"><a class=\"markdownIt-Anchor\" href=\"#先看一眼-当前已经有的日志文件-业务日志和gc日志\">#</a> 先看一眼 当前已经有的日志文件，业务日志和 GC 日志</h3>\n<p>先估摸的看下，OOM 出现，一般都是话务量场景，有大量请求，这第一点属于是能看出来就好，看不来就算了</p>\n<h3 id=\"分析dump文件\"><a class=\"markdownIt-Anchor\" href=\"#分析dump文件\">#</a> 分析 dump 文件</h3>\n<p>为啥没有优先用这个方法呢，因为现网都是 jre, 没有 jdk, 一般也咩有加上堆转储的启动参数，没有现成的 dump 文件<br>\n这里分两种情况</p>\n<ol>\n<li>开启了堆转储参数，且 oom 已发生，这时候 JVM 会自动给生成 dump 文件 <pre><code> \njava -XX:+HeapDumpOnOutOfMemoryError \n -XX:HeapDumpPath&#x3D;~&#x2F;dumps&#x2F;java_heapdump.hprof\n -jar test.jar\n-XX:+HeapDumpOnOutOfMemoryError：当发生OutOfMemoryError时，生成堆转储文件。\n-XX:HeapDumpPath&#x3D;~&#x2F;dumps&#x2F;java_heapdump.hprof\n </code></pre>\n</li>\n<li>没有开启堆转储参数，那只能用命令了 <pre><code>jmap -dump:format&#x3D;b,file&#x3D;test.hprof 1234\njamp -dump:format&#x3D;b,file&#x3D;[文件名] [pid]\npid 用jsp 或者 ps -ef | grep java</code></pre>\n</li>\n</ol>\n<h2 id=\"dump文件分析\"><a class=\"markdownIt-Anchor\" href=\"#dump文件分析\">#</a> dump 文件分析</h2>\n<p>说实话挺简单的，把 dump 文件下载到本地，用 visualvm 载入，就看哪个类占用最多就可以了，排除掉 char [] 和 String<br>\n 如果程序里面咩有用自定义类，而全用 Map 的，可以动手打人了，所以说有条军规就是让别用 Map 来，弄贼多魔法值 Key, 维护和定位都麻烦.<br>\nMap 的情况真的很难定位，排除 Map</p>\n",
            "tags": [
                "java",
                "定位"
            ]
        },
        {
            "id": "http://example.com/2023/05/20/%E5%AE%9A%E4%BD%8D-%E5%BA%94%E7%94%A8%E9%A2%91%E7%B9%81FGC/",
            "url": "http://example.com/2023/05/20/%E5%AE%9A%E4%BD%8D-%E5%BA%94%E7%94%A8%E9%A2%91%E7%B9%81FGC/",
            "title": "定位和解决应用频繁Full GC问题",
            "date_published": "2023-05-20T13:17:01.000Z",
            "content_html": "<h2 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>在话务量环境中，我们发现接口响应变慢。由于该环境中运行着多种业务，难以直接判断是哪个业务引发了这个问题。因此，我们需要进行深入的性能分析和问题定位。</p>\n<h2 id=\"问题定位过程\"><a class=\"markdownIt-Anchor\" href=\"#问题定位过程\">#</a> 问题定位过程</h2>\n<h3 id=\"1-使用jstat观察垃圾收集情况\"><a class=\"markdownIt-Anchor\" href=\"#1-使用jstat观察垃圾收集情况\">#</a> 1. 使用 jstat 观察垃圾收集情况</h3>\n<p>首先，我们使用 <code>jstat -gcutil</code>  命令查看垃圾收集的情况。观察结果显示：</p>\n<ul>\n<li>老年代使用率较高</li>\n<li>GC 次数和时间明显偏多</li>\n</ul>\n<p>这些迹象表明系统可能正在频繁进行 Full GC。</p>\n<h3 id=\"2-使用jmap分析堆内存\"><a class=\"markdownIt-Anchor\" href=\"#2-使用jmap分析堆内存\">#</a> 2. 使用 jmap 分析堆内存</h3>\n<p>接下来，我们使用 <code>jmap -heap &lt;pid&gt;</code>  命令查看堆内存使用情况，发现内存使用量确实很高。</p>\n<p>为了进一步分析，我们执行了以下步骤：</p>\n<ol>\n<li>手动触发一次 Full GC： <code>jmap -histo:live &lt;pid&gt;</code></li>\n<li>再次执行 <code>jmap -heap &lt;pid&gt;</code>  查看堆内存情况</li>\n</ol>\n<p>执行完后，再执行 <code>jmap -heap &lt;pid&gt;</code> ，没有发现明显变化。</p>\n<p>这时我们推测，JVM 中可能没有多少可回收的垃圾，问题可能出在某个业务模块使用了大量缓存（如 Map 等数据结构）。不过，这个结论还不够确定，因为 <code>jmap -histo:live</code>  的结果可能受到正在执行的线程影响，这一步得出的结论还不足以定位出具体是哪一块的问题。</p>\n<h3 id=\"3-分析堆转储文件\"><a class=\"markdownIt-Anchor\" href=\"#3-分析堆转储文件\">#</a> 3. 分析堆转储文件</h3>\n<p>为了获得更详细的信息，我们决定生成堆转储文件进行分析：</p>\n<pre><code>jmap -dump:format=b,file=/home/xxx/sch/my.dump &lt;pid&gt;\n</code></pre>\n<p>我们使用 VisualVM 分析 dump 文件（也可以使用 MAT）。分析结果显示：</p>\n<ul>\n<li><code>String</code>  对象数量异常多</li>\n<li><code>SimpleMessage</code>  对象数量异常多</li>\n<li><code>LinkedBlockingQueue$Node</code>  对象数量异常多</li>\n</ul>\n<p>通过代码审查，我们发现这些对象与线程池的任务队列有关。进一步分析发现：</p>\n<ol>\n<li>使用了无界队列</li>\n<li>消费速度跟不上生产速度</li>\n<li>队列中积压了大量任务，从而触发频繁的 Full GC</li>\n</ol>\n<p>我们意识到，如果继续这样下去，很可能会导致 OutOfMemoryError。</p>\n<h2 id=\"解决方案\"><a class=\"markdownIt-Anchor\" href=\"#解决方案\">#</a> 解决方案</h2>\n<p>问题定位后，我们考虑了以下解决方案：</p>\n<ol>\n<li>\n<p>修改队列类型：考虑到原设计可能有其合理性，我们暂时没有采取这个方案。</p>\n</li>\n<li>\n<p>优化任务处理逻辑：</p>\n<ul>\n<li>将原来使用 <code>synchronized</code>  的地方改为使用 <code>Lock</code> ，降低锁的粒度。</li>\n<li>实现批量处理逻辑：当队列中任务数量超过阈值时，启用批量处理模式，提高处理效率。</li>\n</ul>\n</li>\n</ol>\n<p>实施步骤：</p>\n<ol>\n<li>我们首先在话务量环境中部署了第一个优化方案（使用 <code>Lock</code>  替换 <code>synchronized</code> ）。</li>\n<li>验证没有问题后，这解决了紧急情况。</li>\n<li>随后，我们又实现并部署了批量处理的优化，进一步提升了系统性能。</li>\n</ol>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>这次问题的解决过程展示了系统性能优化的一般步骤：</p>\n<ol>\n<li>发现问题：监控系统性能指标。</li>\n<li>初步分析：使用 JVM 工具如 <code>jstat</code>  和 <code>jmap</code>  快速定位可能的问题区域。</li>\n<li>深入分析：生成并分析堆转储文件，结合代码审查找出根本原因。</li>\n<li>制定方案：根据分析结果设计优化方案。</li>\n<li>逐步实施：先解决紧急问题，然后进行进一步的优化。</li>\n<li>持续监控：部署优化方案后继续监控系统，确保问题得到解决。</li>\n</ol>\n",
            "tags": [
                "java",
                "定位",
                "JVM",
                "性能优化",
                "垃圾回收"
            ]
        }
    ]
}