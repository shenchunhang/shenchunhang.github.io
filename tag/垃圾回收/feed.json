{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"垃圾回收\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/05/20/%E5%AE%9A%E4%BD%8D-%E5%BA%94%E7%94%A8%E9%A2%91%E7%B9%81FGC/",
            "url": "http://example.com/2023/05/20/%E5%AE%9A%E4%BD%8D-%E5%BA%94%E7%94%A8%E9%A2%91%E7%B9%81FGC/",
            "title": "定位和解决应用频繁Full GC问题",
            "date_published": "2023-05-20T13:17:01.000Z",
            "content_html": "<h2 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>在话务量环境中，我们发现接口响应变慢。由于该环境中运行着多种业务，难以直接判断是哪个业务引发了这个问题。因此，我们需要进行深入的性能分析和问题定位。</p>\n<h2 id=\"问题定位过程\"><a class=\"markdownIt-Anchor\" href=\"#问题定位过程\">#</a> 问题定位过程</h2>\n<h3 id=\"1-使用jstat观察垃圾收集情况\"><a class=\"markdownIt-Anchor\" href=\"#1-使用jstat观察垃圾收集情况\">#</a> 1. 使用 jstat 观察垃圾收集情况</h3>\n<p>首先，我们使用 <code>jstat -gcutil</code>  命令查看垃圾收集的情况。观察结果显示：</p>\n<ul>\n<li>老年代使用率较高</li>\n<li>GC 次数和时间明显偏多</li>\n</ul>\n<p>这些迹象表明系统可能正在频繁进行 Full GC。</p>\n<h3 id=\"2-使用jmap分析堆内存\"><a class=\"markdownIt-Anchor\" href=\"#2-使用jmap分析堆内存\">#</a> 2. 使用 jmap 分析堆内存</h3>\n<p>接下来，我们使用 <code>jmap -heap &lt;pid&gt;</code>  命令查看堆内存使用情况，发现内存使用量确实很高。</p>\n<p>为了进一步分析，我们执行了以下步骤：</p>\n<ol>\n<li>手动触发一次 Full GC： <code>jmap -histo:live &lt;pid&gt;</code></li>\n<li>再次执行 <code>jmap -heap &lt;pid&gt;</code>  查看堆内存情况</li>\n</ol>\n<p>执行完后，再执行 <code>jmap -heap &lt;pid&gt;</code> ，没有发现明显变化。</p>\n<p>这时我们推测，JVM 中可能没有多少可回收的垃圾，问题可能出在某个业务模块使用了大量缓存（如 Map 等数据结构）。不过，这个结论还不够确定，因为 <code>jmap -histo:live</code>  的结果可能受到正在执行的线程影响，这一步得出的结论还不足以定位出具体是哪一块的问题。</p>\n<h3 id=\"3-分析堆转储文件\"><a class=\"markdownIt-Anchor\" href=\"#3-分析堆转储文件\">#</a> 3. 分析堆转储文件</h3>\n<p>为了获得更详细的信息，我们决定生成堆转储文件进行分析：</p>\n<pre><code>jmap -dump:format=b,file=/home/xxx/sch/my.dump &lt;pid&gt;\n</code></pre>\n<p>我们使用 VisualVM 分析 dump 文件（也可以使用 MAT）。分析结果显示：</p>\n<ul>\n<li><code>String</code>  对象数量异常多</li>\n<li><code>SimpleMessage</code>  对象数量异常多</li>\n<li><code>LinkedBlockingQueue$Node</code>  对象数量异常多</li>\n</ul>\n<p>通过代码审查，我们发现这些对象与线程池的任务队列有关。进一步分析发现：</p>\n<ol>\n<li>使用了无界队列</li>\n<li>消费速度跟不上生产速度</li>\n<li>队列中积压了大量任务，从而触发频繁的 Full GC</li>\n</ol>\n<p>我们意识到，如果继续这样下去，很可能会导致 OutOfMemoryError。</p>\n<h2 id=\"解决方案\"><a class=\"markdownIt-Anchor\" href=\"#解决方案\">#</a> 解决方案</h2>\n<p>问题定位后，我们考虑了以下解决方案：</p>\n<ol>\n<li>\n<p>修改队列类型：考虑到原设计可能有其合理性，我们暂时没有采取这个方案。</p>\n</li>\n<li>\n<p>优化任务处理逻辑：</p>\n<ul>\n<li>将原来使用 <code>synchronized</code>  的地方改为使用 <code>Lock</code> ，降低锁的粒度。</li>\n<li>实现批量处理逻辑：当队列中任务数量超过阈值时，启用批量处理模式，提高处理效率。</li>\n</ul>\n</li>\n</ol>\n<p>实施步骤：</p>\n<ol>\n<li>我们首先在话务量环境中部署了第一个优化方案（使用 <code>Lock</code>  替换 <code>synchronized</code> ）。</li>\n<li>验证没有问题后，这解决了紧急情况。</li>\n<li>随后，我们又实现并部署了批量处理的优化，进一步提升了系统性能。</li>\n</ol>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>这次问题的解决过程展示了系统性能优化的一般步骤：</p>\n<ol>\n<li>发现问题：监控系统性能指标。</li>\n<li>初步分析：使用 JVM 工具如 <code>jstat</code>  和 <code>jmap</code>  快速定位可能的问题区域。</li>\n<li>深入分析：生成并分析堆转储文件，结合代码审查找出根本原因。</li>\n<li>制定方案：根据分析结果设计优化方案。</li>\n<li>逐步实施：先解决紧急问题，然后进行进一步的优化。</li>\n<li>持续监控：部署优化方案后继续监控系统，确保问题得到解决。</li>\n</ol>\n",
            "tags": [
                "java",
                "定位",
                "JVM",
                "性能优化",
                "垃圾回收"
            ]
        }
    ]
}