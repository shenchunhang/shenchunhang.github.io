{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"struts2\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/03/22/struts2%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0-%E5%8F%AA%E8%83%BD%E6%8E%A5%E6%94%B6256%E4%B8%AA/",
            "url": "http://example.com/2024/03/22/struts2%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0-%E5%8F%AA%E8%83%BD%E6%8E%A5%E6%94%B6256%E4%B8%AA/",
            "title": "struts2集合参数-只能接收256个",
            "date_published": "2024-03-22T13:47:32.000Z",
            "content_html": "<h2 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\">#</a> 背景</h2>\n<p>测试那边转过来一个问题单，开发这边初步定位是 struts 框架接收集合参数只能接收到 256 个</p>\n<h2 id=\"定位\"><a class=\"markdownIt-Anchor\" href=\"#定位\">#</a> 定位</h2>\n<h3 id=\"google一下\"><a class=\"markdownIt-Anchor\" href=\"#google一下\">#</a> google 一下</h3>\n<p>先直接 google 了一下，感觉回答有点偏，说是 struts2.5.15 升级到 2.5.30 就会有这个问题，是 struts 改用 ArrayList 的 TypeConverter, 我自己去代码里面看根本咩有限制</p>\n<pre><code>\npublic Object convertValue(Map&lt;String, Object&gt; context, Object target, Member member, String propertyName, Object value, Class toType) {\nCollection result;\nClass memberType &#x3D; String.class;\n    if (target !&#x3D; null) {\n        memberType &#x3D; objectTypeDeterminer.getElementClass(target.getClass(), propertyName, null);\n        if (memberType &#x3D;&#x3D; null) {\n            memberType &#x3D; String.class;\n        }\n    }\n    if (toType.isAssignableFrom(value.getClass())) {\n        &#x2F;&#x2F; no need to do anything\n        result &#x3D; (Collection) value;\n    } else if (value.getClass().isArray()) {\n        Object[] objArray &#x3D; (Object[]) value;\n        TypeConverter converter &#x3D; getTypeConverter(context);\n        result &#x3D; createCollection(toType, memberType, objArray.length);\n        for (Object anObjArray : objArray) {\n            Object convertedValue &#x3D; converter.convertValue(context, target, member, propertyName, anObjArray, memberType);\n            if (!TypeConverter.NO_CONVERSION_POSSIBLE.equals(convertedValue)) {\n                result.add(convertedValue);\n            }\n        }\n    } else if (Collection.class.isAssignableFrom(value.getClass())) {\n        Collection col &#x3D; (Collection) value;\n        TypeConverter converter &#x3D; getTypeConverter(context);\n        result &#x3D; createCollection(toType, memberType, col.size());\n        for (Object aCol : col) {\n            Object convertedValue &#x3D; converter.convertValue(context, target, member, propertyName, aCol, memberType);\n            if (!TypeConverter.NO_CONVERSION_POSSIBLE.equals(convertedValue)) {\n                result.add(convertedValue);\n            }\n        }\n    } else {\n        result &#x3D; createCollection(toType, memberType, -1);\n        TypeConverter converter &#x3D; getTypeConverter(context);\n        Object convertedValue &#x3D; converter.convertValue(context, target, member, propertyName, value, memberType);\n        if (!TypeConverter.NO_CONVERSION_POSSIBLE.equals(convertedValue)) {\n            result.add(convertedValue);\n        }\n    }\n    return result;\n}</code></pre>\n<h4 id=\"strutsognlexpressionmaxlength\"><a class=\"markdownIt-Anchor\" href=\"#strutsognlexpressionmaxlength\">#</a> struts.ognl.expressionMaxLength</h4>\n<p>这时候就这专门去 clone 了一下 struts 的仓库<br>\n先切换到 2.5.33 版本，然后曲剧检索了一下 256, 还真让找到了一处配置</p>\n<img loading=\"lazy\" data-src=\"/2024/03/22/struts2%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0-%E5%8F%AA%E8%83%BD%E6%8E%A5%E6%94%B6256%E4%B8%AA/Snipaste_2024-04-22_22-01-35.png\" class=\"\" title=\"struts.ognl.expressionMaxLength\">\n<p>但是被注释掉了，翻译过来，不配置的话，就不会被限制，实际情况，本来就没有设置这个参数，应该和在这个配置没有关系，而且实际给的参数列表超过了 256, 这个参数是接收 OGNL 的个数，我们出现的问题是 OGNL 集合参数被限制在 256 以内，</p>\n<h4 id=\"strutsognlautogrowthcollectionlimit\"><a class=\"markdownIt-Anchor\" href=\"#strutsognlautogrowthcollectionlimit\">#</a> struts.ognl.autoGrowthCollectionLimit</h4>\n<p>无奈，只得继续看提交记录，好在提交记录 并不是很多，看着看着，又发现了一处</p>\n<pre><code>\npublic Object getProperty(Map context, Object target, Object name) throws OgnlException {\n    if (ReflectionContextState.isGettingByKeyProperty(context)\n            || name.equals(XWorkCollectionPropertyAccessor.KEY_PROPERTY_FOR_CREATION)) {\n        return _sAcc.getProperty(context, target, name);\n    } else if (name instanceof String) {\n        return super.getProperty(context, target, name);\n    }\n    ReflectionContextState.updateCurrentPropertyPath(context, name);\n    Class lastClass &#x3D; (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n    String lastProperty &#x3D; (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n    \n    if (name instanceof Number\n            &amp;&amp; ReflectionContextState.isCreatingNullObjects(context)\n            &amp;&amp; objectTypeDeterminer.shouldCreateIfNew(lastClass,lastProperty,target,null,true)) {\n\n        List list &#x3D; (List) target;\n        int index &#x3D; ((Number) name).intValue();\n        int listSize &#x3D; list.size();\n\n        if (lastClass &#x3D;&#x3D; null || lastProperty &#x3D;&#x3D; null) {\n            return super.getProperty(context, target, name);\n        }\n        Class beanClass &#x3D; objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n        if (listSize &lt;&#x3D; index) {\n            Object result;\n            if (index &gt; autoGrowCollectionLimit) {\n                throw new OgnlException(&quot;Error auto growing collection size to &quot; + index + &quot; which limited to &quot;\n                                        + autoGrowCollectionLimit);\n            }\n            for (int i &#x3D; listSize; i &lt; index; i++) {\n                list.add(null);\n            }\n            try {\n                list.add(index, result &#x3D; objectFactory.buildBean(beanClass, context));\n            } catch (Exception exc) {\n                throw new XWorkException(exc);\n            }\n            return result;\n        } else if (list.get(index) &#x3D;&#x3D; null) {\n            Object result;\n            try {\n                list.set(index, result &#x3D; objectFactory.buildBean(beanClass, context));\n            } catch (Exception exc) {\n                throw new XWorkException(exc);\n            }\n            return result;\n        }\n    }\n    return super.getProperty(context, target, name);\n}</code></pre>\n<img loading=\"lazy\" data-src=\"/2024/03/22/struts2%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0-%E5%8F%AA%E8%83%BD%E6%8E%A5%E6%94%B6256%E4%B8%AA/Snipaste_2024-04-22_22-28-18.png\" class=\"\" title=\"struts.ognl.autoGrowthCollectionLimit\">\n<p>早知道就一起检索 255 了，还看了这么多提交记录，这次直接到 struts 的配置里面加上，测试了一下，果然可以</p>\n<h4 id=\"吐槽\"><a class=\"markdownIt-Anchor\" href=\"#吐槽\">#</a> 吐槽</h4>\n<p>struts 真的可以，增加了 default 配置，也不写到版本更新里面去，还得自己来看源码才能知道</p>\n<h4 id=\"推想\"><a class=\"markdownIt-Anchor\" href=\"#推想\">#</a> 推想</h4>\n<p>struts.ognl.expressionMaxLength 这个配置，看了一下他们的 issue, 还是感觉挺好笑的，2.5.21 加上后，2.5.22 又给注释掉，实际外发的版本 2.5.21 都没了，<br>\n<a href=\"https://github.com/apache/struts/pull/380\">struts.ognl.expressionMaxLength 讨论</a></p>\n<img loading=\"lazy\" data-src=\"/2024/03/22/struts2%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0-%E5%8F%AA%E8%83%BD%E6%8E%A5%E6%94%B6256%E4%B8%AA/Snipaste_2024-04-22_22-44-21.png\" class=\"\" title=\"2.5.21缺失\">",
            "tags": [
                "java",
                "定位",
                "struts2"
            ]
        }
    ]
}